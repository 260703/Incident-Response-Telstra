# www.theforage.com - Telstra Cyber Task 3
# Improved Firewall Server Handler

import logging
import os
import re
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer

# Configuration
HOST = os.getenv("FIREWALL_HOST", "localhost")
PORT = int(os.getenv("FIREWALL_PORT", "8000"))
LOG_FILE = os.getenv("FIREWALL_LOG_FILE", "firewall.log")

# Logging configuration with rotation
from logging.handlers import RotatingFileHandler
log_handler = RotatingFileHandler(LOG_FILE, maxBytes=1024*1024, backupCount=3)
logging.basicConfig(handlers=[log_handler], level=logging.INFO, format="%(asctime)s - %(message)s")

# Malicious header patterns (case-insensitive, substring matching)
BAD_HEADER_PATTERNS = [
    ("suffix", "%>//"),
    ("c1", "Runtime"),
    ("c2", "<%"),
    ("dnt", "1"),  # DNT can be upper or lower case
    ("content-type", "application/x-www-form-urlencoded"),
]

# Malicious path patterns
BAD_PATHS = ["/tomcatwar.jsp"]

class ServerHandler(BaseHTTPRequestHandler):
    """Handles HTTP requests (GET and POST) with basic firewall logic."""

    def _is_malicious(self):
        # Check if the path matches any known exploit paths
        if self.path.lower() in BAD_PATHS:
            # Headers: make lookup case-insensitive and match substrings
            for header_key, bad_value in BAD_HEADER_PATTERNS:
                for req_header, req_value in self.headers.items():
                    if req_header.lower() == header_key and bad_value.lower() in req_value.lower():
                        return True
        return False

    def _block_request(self):
        client_ip = self.client_address[0]
        logging.info(f"Blocked malicious request from {client_ip} - Path: {self.path} - Headers: {dict(self.headers)}")
        self.send_error(403, "Request blocked due to firewall")

    def _allow_request(self):
        client_ip = self.client_address[0]
        logging.info(f"Allowed request from {client_ip} - Path: {self.path}")
        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(b'{"success": true}')

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(b'{"status": "healthy"}')
            return

        try:
            if self._is_malicious():
                self._block_request()
            else:
                self._allow_request()
        except Exception as e:
            logging.error(f"Exception in GET handler: {e}")
            self.send_error(500, "Internal Server Error")

    def do_POST(self):
        try:
            if self._is_malicious():
                self._block_request()
            else:
                self._allow_request()
        except Exception as e:
            logging.error(f"Exception in POST handler: {e}")
            self.send_error(500, "Internal Server Error")

if __name__ == "__main__":
    server = ThreadingHTTPServer((HOST, PORT), ServerHandler)
    print("[+] Firewall Server")
    print(f"[+] HTTP Web Server running on: {HOST}:{PORT}")

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        logging.error(f"Exception in server: {e}")

    server.server_close()
    print("[+] Server terminated. Exiting...")
    exit(0)